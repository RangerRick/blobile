{"version":3,"mappings":"+pFAI6BA,wBAAhBC,GAAgBD,kCAAG,WAAOE,GAAP,wGAAgB,IAAIC,QAAQ,SAACC,EAASC,GAClE,IAAMC,EAAS,IAAIC,WACnBD,EAAOE,OAAS,WACZ,IAAMC,EAAeH,EAAOI,OACtBC,EAA0BF,EAAaG,OAAOH,EAAaI,QAAQ,KAAO,GAChFT,EAAQO,IAEZL,EAAOQ,QAAWC,mBAAUV,EAAOU,IACnCT,EAAOU,cAAcd,MARO,yCAAH,6CAchBe,EAAUC,mBAAQC,mBAAmBD,GAC7CE,QAAQ,uBAAwBC,oBAChCD,QAAQ,QAASE,SAKTC,EAAUL,mBAAQA,EAAIE,QAAQ,mBAAoBC,qBCNlDG,EAAa,WACtB,IAAMC,EAAS,GACTC,EAAM,GACZ,IAAKC,SAASC,OACV,OAAOH,EAEX,IANsBI,MAMNF,SAASC,OAAOE,MAAM,MAAQ,IANxB,IAOtB,2BAA8B,KAE1BC,IAF0BF,QAENT,QAAQ,IAAK,cAAcU,MAAM,cAArD,GAAKE,EAALD,KAAQE,EAARF,KACAC,EAAIT,EAAOS,GAAGE,OACdD,EAAIV,EAAOU,GAAGC,OACdR,EAAIM,GAAKC,GAZS,8BAetB,IADA,IACAE,MADgBC,OAAOC,QAAQX,GAC/BS,gCAAYG,EAAZC,KAAiBC,EAAjBD,KACId,EAAOgB,KAAK,CACRH,MACAE,UAGR,OAAOf,GA2BEiB,EAAe,WACxB,IADwBC,MACRhB,SAASC,OAAOE,MAAM,MAAQ,IADtB,IAExB,gCAAWF,EAAXe,QACIhB,SAASC,OAASA,EACbR,QAAQ,MAAO,IACfA,QAAQ,MAFKQ,qBAEe,IAAIgB,MAAOC,cAF1BjB,aAHE,gCClBfkB,EAAmB,SAACC,GAAiB,IAARC,EAAQC,0DACxCxB,EAASW,OAAOc,OAAO,CAAEC,OAAQJ,EAAQI,QAAU,MAAOC,QAASL,EAAQK,SAAWJ,GAGtFK,EAhDmB,WAAW,IAAVD,EAAUH,0DAC9BK,EAAelB,OAAOmB,KAAKH,GAMjC,OAJmBI,OADQD,KAAKH,GAAS1B,IAAIM,mBAAKA,EAAEyB,sBACrBC,OAAO,SAACC,EAAKrB,EAAKsB,GAAX,OAClCD,EAAIrB,GAAOc,EAAQE,EAAaM,IACzBD,GACR,IANsB,CA+CYZ,EAAQK,SACxB,iBAAmB,GAExC,GAA4B,iBAAjBL,EAAQc,KACfpC,EAAOqC,KAAOf,EAAQc,aAGjBR,EAAKU,SAAS,qCAAsC,CAEzD,IADA,IAAMC,EAAS,IAAIC,gBACnBC,MAA2B9B,OAAOC,QAAQU,EAAQc,MAAQ,IAA1DK,gCAAY5B,EAAZ6B,KAAiB3B,EAAjB2B,KACIH,EAAOI,IAAI9B,EAAKE,GAEpBf,EAAOqC,KAAOE,EAAOK,mBAEhBhB,EAAKU,SAAS,uBAAwB,CAC3C,IAAMO,EAAO,IAAIC,SACjB,GAAIxB,EAAQc,gBAAgBU,SACxBxB,EAAQc,KAAKW,QAAQ,SAAChC,EAAOF,GACzBgC,EAAKG,OAAOnC,EAAKE,UAIrB,cAAgBJ,OAAOmB,KAAKR,EAAQc,MAApCa,oBAASpC,OACLgC,EAAKG,OAAOnC,EAAKS,EAAQc,KAAKvB,IAGtCb,EAAOqC,KAAOQ,EACd,IAAMlB,EAAU,IAAIuB,QAAQlD,EAAO2B,SACnCA,SAAe,gBACf3B,EAAO2B,QAAUA,OAEZC,EAAKU,SAAS,qBACK,iBAAjBhB,EAAQc,QACfpC,EAAOqC,KAAOc,KAAKC,UAAU9B,EAAQc,OAEzC,OAAOpC,GAMEqD,EAAO,iDAAG,WAAO/B,GAAP,yGAIbgC,OAHAC,EAAclC,EAAiBC,EAASA,EAAQkC,eAChDC,EA5Ea,SAAClB,GAAD,IAASmB,IAATlC,gEACde,EAsBEvC,OApBeY,QAAQ2B,GAAQN,OAAO,SAAC0B,EAAaC,GACvD,IACIC,EACAC,EAFJC,IAAqBH,EAArB,GAAO/C,EAAPkD,KAAYhD,EAAZgD,KAGA,OAAIC,MAAMC,QAAQlD,IACd+C,EAAO,GACP/C,EAAMgC,QAAQtD,YACVoE,EAAeH,EAAehE,mBAAmBD,GAAOA,EACxDqE,aAAWjD,EAAXiD,YAAkBD,EAAlBC,OAGJA,EAAKI,MAAM,GAAG,KAGdL,EAAeH,EAAehE,mBAAmBqB,GAASA,EAC1D+C,YAAUjD,EAAViD,YAAiBD,IAXjBG,UAaML,EAbNK,YAaqBF,IAC1B,IAEW3E,OAAO,GArBV,KAFQ,CA4EcmC,EAAQiB,OAAQjB,EAAQ6C,uBACnDC,EAAMX,YAAenC,EAAQ8C,IAAvBX,YAA8BA,GAAcnC,EAAQ8C,IAH7CC,SAIIC,MAAMF,EAAKb,GAJf,OAIbD,EAJae,OAKbE,EAAcjB,EAAS3B,QAAQ6C,IAAI,iBAAmB,GALzCC,EAOanB,EAASoB,GAAKpD,EAAU,GAPrCqD,IAObC,oBAPa,MAOE,OAPFD,QASfJ,EAAYjC,SAAS,sBACrBsC,EAAe,QAGXA,GAbWP,OAcV,gBAdUA,MAeV,SAfUA,QAmBV,SAnBUA,SAsBV,aAtBUA,6BAgBL5F,OAhBK4F,UAgBQf,EAAS7E,OAhBjB,QAiBX2D,OADM3D,EAhBK4F,iBAiBE7F,EAAiBC,GAjBnB,eAiBX2D,EAjBWiC,oCAoBXjC,OApBWiC,UAoBEf,EAASuB,OApBX,eAoBXzC,EApBWiC,oCAyBXjC,OAzBWiC,UAyBEf,EAASwB,OAzBX,QAyBX1C,EAzBWiC,sBA4Bb1C,EAAU,GA5BG0C,mBA6BnBf,EAAS3B,QAAQoB,QAAQ,SAAChC,EAAOF,GAC7Bc,EAAQd,GAAOE,IAEZ,CACHqB,OACAT,UACAoD,OAAQzB,EAASyB,OACjBX,IAAKd,EAASc,OApCC,0CAAH,sDA2CPI,EAAG,iDAAG,WAAOlD,GAAP,wGAAmB+B,EAAQ1C,OAAOc,OAAOd,OAAOc,OAAO,GAAIH,GAAU,CAAEI,OAAQ,UAA/E,yCAAH,sDAKHsD,EAAI,iDAAG,WAAO1D,GAAP,wGAAmB+B,EAAQ1C,OAAOc,OAAOd,OAAOc,OAAO,GAAIH,GAAU,CAAEI,OAAQ,WAA/E,yCAAH,sDAKJuD,EAAG,iDAAG,WAAO3D,GAAP,wGAAmB+B,EAAQ1C,OAAOc,OAAOd,OAAOc,OAAO,GAAIH,GAAU,CAAEI,OAAQ,UAA/E,yCAAH,sDAKHwD,EAAK,iDAAG,WAAO5D,GAAP,wGAAmB+B,EAAQ1C,OAAOc,OAAOd,OAAOc,OAAO,GAAIH,GAAU,CAAEI,OAAQ,YAA/E,yCAAH,sDAKLyD,EAAG,iDAAG,WAAO7D,GAAP,wGAAmB+B,EAAQ1C,OAAOc,OAAOd,OAAOc,OAAO,GAAIH,GAAU,CAAEI,OAAQ,aAA/E,yCAAH,sDCzJT0D,kQACHC,mBAAcC,EAMVC,EANJF,4GACIG,eADUF,OAMVG,EAAKpC,SAALkC,kCAAe,WAAOjE,GAAP,wGAAmBoE,EAAgBpE,IAAnC,yCAAf,6CAKAmE,EAAKjB,IAAL,iDAAW,WAAOlD,GAAP,wGAAmBoE,EAAYpE,IAA/B,yCAAX,sDAKAmE,EAAKT,KAAL,iDAAY,WAAO1D,GAAP,wGAAmBoE,EAAapE,IAAhC,yCAAZ,sDAKAmE,EAAKR,IAAL,iDAAW,WAAO3D,GAAP,wGAAmBoE,EAAYpE,IAA/B,yCAAX,sDAKAmE,EAAKP,MAAL,iDAAa,WAAO5D,GAAP,wGAAmBoE,EAAcpE,IAAjC,yCAAb,sDAKAmE,EAAKN,IAAL,iDAAW,WAAO7D,GAAP,wGAAmBoE,EAAYpE,IAA/B,yCAAX,sDAIAmE,EAAKE,cAAL,iDAAqB,WAErBrE,GAFqB,6FAGXsE,EAAUC,IACV7F,EAAS,GAJE8F,IAKIF,GALJ,IAKjB,2BAAWzF,EAAX4F,QACI/F,EAAOG,EAAOU,KAAOV,EAAOY,MANf,uDAQVf,GARU,yCAArB,sDAaAyF,EAAK1F,WAAL,iDAAkB,WAAOuB,GAAP,wGAIP,CAAEsE,QADOC,MAHF,yCAAlB,sDAYAJ,EAAKO,UAAL,iDAAiB,WAAO1E,GAAP,6FACLT,EAAwCS,EAAxCT,IAAKE,EAAmCO,EAAnCP,MADAkF,EACmC3E,EAA5B4E,eADP,MACiB,GADjBD,IACmC3E,EAAd6E,KF1DrB,SAACtF,EAAKE,GAAiB,IAAVO,EAAUE,0DAEtC4E,EAAa5G,EAAOqB,GACpBgD,EAAerE,EAAOuB,GAEtBmF,uBAAwB5E,EAAQ4E,SAAW,IAAIvG,QAAQ,WAAY,KACnEwG,GAAQ7E,EAAQ6E,MAAQ,KAAKxG,QAAQ,QAAS,IACpDO,SAASC,OAATD,UAAqBkG,EAArBlG,YAAmC2D,GAAgB,IAAnD3D,OAAwDgG,EAAxDhG,kBAAyEiG,GAPpD,CE2DItF,EAAKE,EAAO,CAAEmF,UAASC,UAF3B,MAC4B,GAD5BE,6CAAjB,sDAQAZ,EAAKa,UAAL,iDAAiB,WAAOhF,GAAP,wGF3BCT,YACtB,IADsBA,MACNd,KADMc,IAEtB,gCAAWV,EAAXoG,QACI,GAAIpG,EAAOU,MAAQA,EACf,OAAOV,GAJOU,8BAOtB,MAAO,CACHA,MACAE,MAAO,IATWF,CE2BmCS,EAAQT,MAA5C,yCAAjB,sDAKA4E,EAAKe,aAAL,iDAAoB,WAAOlF,GAAP,+EFfxBpB,SAASC,OAATD,UEe+DoB,EAAQT,IFfvEX,gBEewB,yCAApB,sDAIAuF,EAAKxE,aAAL,iDAAoB,WAEpBK,GAFoB,wGAERuE,KAFQ,yCAApB,sDAMAJ,EAAKgB,mBAALC,KAAKD,wBAAkB,qHAAYZ,KAAZ,yCAKvBJ,EAAKkB,WAAL,iDAAkB,WAAOrF,GAAP,8FACRsF,EAAW,IAAI9D,UACZE,OAAO1B,EAAQuF,KAAMvF,EAAQ7C,MAAQ,aACxCqI,EAAenG,OAAOc,OAAOd,OAAOc,OAAO,GAAIH,GAAU,CAAEe,KAAMuE,EAAUlF,OAAQ,SAH3EqF,kBAIPzB,EAAKN,KAAK8B,IAJH,yCAAlB,sDAUArB,EAAKuB,aAAL,iDAAoB,WAAO1F,GAAP,mHAEVgC,OADAC,EAAcmC,EAAyBpE,EAASA,EAAQkC,eAD9CyD,SAEO3C,MAAMhD,EAAQ8C,IAAKb,GAF1B,UAEVD,EAFU2D,SAIE,MAAZ3F,SAAkDA,EAAQ4F,UAJhD,sBAMQ,MAAb5D,SAAoDA,EAASjB,MANxD,iBASNxD,EAASyE,EAASjB,KAAK8E,YACzBC,EAAQ,EACRC,EAAS,GACP9C,EAAcjB,EAAS3B,QAAQ6C,IAAI,gBACnC8C,EAAgBC,SAASjE,EAAS3B,QAAQ6C,IAAI,mBAAqB,IAAK,IAblE,OAeMzD,OAfNkG,UAesBpI,EAAO2I,OAf7B,oBAeAC,EAfAC,EAeAD,KAAM1G,EAfN2G,EAeM3G,OACV0G,EAhBI,qDAkBRJ,EAAOrG,KAAKD,GACZqG,IAAoB,MAAVrG,SAA8CA,EAAM4G,SAAW,EAOzErC,EAAKsC,gBAAgB,WANN,CACXhG,KAAM,WACNwC,IAAK9C,EAAQ8C,IACbgD,QACAE,kBAxBI,+BA8BZ,IAFIO,EAAY,IAAIC,WAAWV,GAC3BW,EAAW,EACfC,MAAoBX,EAApBW,oBAAoBX,KAATY,EAAXC,QAGIL,EAAUlF,IAAIsF,EAAOF,GACrBA,GAAYE,EAAMN,QAEtBlJ,EAAO,IAAI0J,KAAK,CAACN,EAAUO,QAAS,CAAExG,KAAM2C,YApChC0C,wBAOZxI,EAAO,IAAI0J,KAPC,gCAKZ1J,OALYwI,UAKC3D,EAAS7E,OALV,QAKZA,EALYwI,wCAsCT,CACHxI,SAvCY,0CAApB,sDAlGJ4G,YADyBgD","names":["n","readBlobAsBase64","blob","Promise","resolve","reject","reader","FileReader","onload","base64String","result","base64StringWithoutTags","substr","indexOf","onerror","error","readAsDataURL","encode","str","encodeURIComponent","replace","decodeURIComponent","escape","decode","getCookies","output","map","document","cookie","_step","split","_s2$replace$split2","k","v","trim","_i","Object","entries","key","_e$_i","value","push","clearCookies","_step2","Date","toUTCString","buildRequestInit","options","extra","arguments","assign","method","headers","type","originalKeys","keys","loweredKeys","toLocaleLowerCase","reduce","acc","index","data","body","includes","params","URLSearchParams","_i2","_Object$entries$_i","set","toString","form","FormData","forEach","append","_i3","Headers","JSON","stringify","request","response","requestInit","webFetchExtra","urlParams","shouldEncode","accumulator","entry","encodedValue","item","_s3","Array","isArray","slice","shouldEncodeUrlParams","url","_context2","fetch","contentType","get","_ref","ok","_ref$responseType","responseType","json","text","status","post","put","patch","del","F","constructor","o","t","super","this","Request","getCookiesMap","cookies","Cookie","_iterator3","_step3","setCookie","_e$expires","expires","path","encodedKey","_e$path","getCookie","_step4","deleteCookie","clearAllCookies","c","uploadFile","formData","name","fetchOptions","_context21","downloadFile","_context22","progress","getReader","bytes","chunks","contentLength","parseInt","read","done","_yield$a$read","length","notifyListeners","allChunks","Uint8Array","position","_i4","chunk","_l","Blob","buffer","WebPlugin"],"sources":["webpack:///node_modules/@capacitor-community/http/dist/esm/utils.js","webpack:///node_modules/@capacitor-community/http/dist/esm/cookie.js","webpack:///node_modules/@capacitor-community/http/dist/esm/request.js","webpack:///node_modules/@capacitor-community/http/dist/esm/web.js"],"sourcesContent":["/**\n * Read in a Blob value and return it as a base64 string\n * @param blob The blob value to convert to a base64 string\n */\nexport const readBlobAsBase64 = async (blob) => new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n        const base64String = reader.result;\n        const base64StringWithoutTags = base64String.substr(base64String.indexOf(',') + 1); // remove prefix \"data:application/pdf;base64,\"\n        resolve(base64StringWithoutTags);\n    };\n    reader.onerror = (error) => reject(error);\n    reader.readAsDataURL(blob);\n});\n/**\n * Safely web encode a string value (inspired by js-cookie)\n * @param str The string value to encode\n */\nexport const encode = (str) => encodeURIComponent(str)\n    .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)\n    .replace(/[()]/g, escape);\n/**\n * Safely web decode a string value (inspired by js-cookie)\n * @param str The string value to decode\n */\nexport const decode = (str) => str.replace(/(%[\\dA-F]{2})+/gi, decodeURIComponent);\n","import { encode, decode } from './utils';\n/**\n * Set a cookie\n * @param key The key to set\n * @param value The value to set\n * @param options Optional additional parameters\n */\nexport const setCookie = (key, value, options = {}) => {\n    // Safely Encoded Key/Value\n    const encodedKey = encode(key);\n    const encodedValue = encode(value);\n    // Clean & sanitize options\n    const expires = `; expires=${(options.expires || '').replace('expires=', '')}`; // Default is \"; expires=\"\n    const path = (options.path || '/').replace('path=', ''); // Default is \"path=/\"\n    document.cookie = `${encodedKey}=${encodedValue || ''}${expires}; path=${path}`;\n};\n/**\n * Gets all HttpCookies\n */\nexport const getCookies = () => {\n    const output = [];\n    const map = {};\n    if (!document.cookie) {\n        return output;\n    }\n    const cookies = document.cookie.split(';') || [];\n    for (const cookie of cookies) {\n        // Replace first \"=\" with CAP_COOKIE to prevent splitting on additional \"=\"\n        let [k, v] = cookie.replace(/=/, 'CAP_COOKIE').split('CAP_COOKIE');\n        k = decode(k).trim();\n        v = decode(v).trim();\n        map[k] = v;\n    }\n    const entries = Object.entries(map);\n    for (const [key, value] of entries) {\n        output.push({\n            key,\n            value,\n        });\n    }\n    return output;\n};\n/**\n * Gets a single HttpCookie given a key\n */\nexport const getCookie = (key) => {\n    const cookies = getCookies();\n    for (const cookie of cookies) {\n        if (cookie.key === key) {\n            return cookie;\n        }\n    }\n    return {\n        key,\n        value: '',\n    };\n};\n/**\n * Deletes a cookie given a key\n * @param key The key of the cookie to delete\n */\nexport const deleteCookie = (key) => {\n    document.cookie = `${key}=; Max-Age=0`;\n};\n/**\n * Clears out cookies by setting them to expire immediately\n */\nexport const clearCookies = () => {\n    const cookies = document.cookie.split(';') || [];\n    for (const cookie of cookies) {\n        document.cookie = cookie\n            .replace(/^ +/, '')\n            .replace(/=.*/, `=;expires=${new Date().toUTCString()};path=/`);\n    }\n};\n","import { readBlobAsBase64 } from './utils';\n/**\n * Normalize an HttpHeaders map by lowercasing all of the values\n * @param headers The HttpHeaders object to normalize\n */\nconst normalizeHttpHeaders = (headers = {}) => {\n    const originalKeys = Object.keys(headers);\n    const loweredKeys = Object.keys(headers).map(k => k.toLocaleLowerCase());\n    const normalized = loweredKeys.reduce((acc, key, index) => {\n        acc[key] = headers[originalKeys[index]];\n        return acc;\n    }, {});\n    return normalized;\n};\n/**\n * Builds a string of url parameters that\n * @param params A map of url parameters\n * @param shouldEncode true if you should encodeURIComponent() the values (true by default)\n */\nconst buildUrlParams = (params, shouldEncode = true) => {\n    if (!params)\n        return null;\n    const output = Object.entries(params).reduce((accumulator, entry) => {\n        const [key, value] = entry;\n        let encodedValue;\n        let item;\n        if (Array.isArray(value)) {\n            item = '';\n            value.forEach(str => {\n                encodedValue = shouldEncode ? encodeURIComponent(str) : str;\n                item += `${key}=${encodedValue}&`;\n            });\n            // last character will always be \"&\" so slice it off\n            item.slice(0, -1);\n        }\n        else {\n            encodedValue = shouldEncode ? encodeURIComponent(value) : value;\n            item = `${key}=${encodedValue}`;\n        }\n        return `${accumulator}&${item}`;\n    }, '');\n    // Remove initial \"&\" from the reduce\n    return output.substr(1);\n};\n/**\n * Build the RequestInit object based on the options passed into the initial request\n * @param options The Http plugin options\n * @param extra Any extra RequestInit values\n */\nexport const buildRequestInit = (options, extra = {}) => {\n    const output = Object.assign({ method: options.method || 'GET', headers: options.headers }, extra);\n    // Get the content-type\n    const headers = normalizeHttpHeaders(options.headers);\n    const type = headers['content-type'] || '';\n    // If body is already a string, then pass it through as-is.\n    if (typeof options.data === 'string') {\n        output.body = options.data;\n    }\n    // Build request initializers based off of content-type\n    else if (type.includes('application/x-www-form-urlencoded')) {\n        const params = new URLSearchParams();\n        for (const [key, value] of Object.entries(options.data || {})) {\n            params.set(key, value);\n        }\n        output.body = params.toString();\n    }\n    else if (type.includes('multipart/form-data')) {\n        const form = new FormData();\n        if (options.data instanceof FormData) {\n            options.data.forEach((value, key) => {\n                form.append(key, value);\n            });\n        }\n        else {\n            for (let key of Object.keys(options.data)) {\n                form.append(key, options.data[key]);\n            }\n        }\n        output.body = form;\n        const headers = new Headers(output.headers);\n        headers.delete('content-type'); // content-type will be set by `window.fetch` to includy boundary\n        output.headers = headers;\n    }\n    else if (type.includes('application/json') ||\n        typeof options.data === 'object') {\n        output.body = JSON.stringify(options.data);\n    }\n    return output;\n};\n/**\n * Perform an Http request given a set of options\n * @param options Options to build the HTTP request\n */\nexport const request = async (options) => {\n    const requestInit = buildRequestInit(options, options.webFetchExtra);\n    const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);\n    const url = urlParams ? `${options.url}?${urlParams}` : options.url;\n    const response = await fetch(url, requestInit);\n    const contentType = response.headers.get('content-type') || '';\n    // Default to 'text' responseType so no parsing happens\n    let { responseType = 'text' } = response.ok ? options : {};\n    // If the response content-type is json, force the response to be json\n    if (contentType.includes('application/json')) {\n        responseType = 'json';\n    }\n    let data;\n    switch (responseType) {\n        case 'arraybuffer':\n        case 'blob':\n            const blob = await response.blob();\n            data = await readBlobAsBase64(blob);\n            break;\n        case 'json':\n            data = await response.json();\n            break;\n        case 'document':\n        case 'text':\n        default:\n            data = await response.text();\n    }\n    // Convert fetch headers to Capacitor HttpHeaders\n    const headers = {};\n    response.headers.forEach((value, key) => {\n        headers[key] = value;\n    });\n    return {\n        data,\n        headers,\n        status: response.status,\n        url: response.url,\n    };\n};\n/**\n * Perform an Http GET request given a set of options\n * @param options Options to build the HTTP request\n */\nexport const get = async (options) => request(Object.assign(Object.assign({}, options), { method: 'GET' }));\n/**\n * Perform an Http POST request given a set of options\n * @param options Options to build the HTTP request\n */\nexport const post = async (options) => request(Object.assign(Object.assign({}, options), { method: 'POST' }));\n/**\n * Perform an Http PUT request given a set of options\n * @param options Options to build the HTTP request\n */\nexport const put = async (options) => request(Object.assign(Object.assign({}, options), { method: 'PUT' }));\n/**\n * Perform an Http PATCH request given a set of options\n * @param options Options to build the HTTP request\n */\nexport const patch = async (options) => request(Object.assign(Object.assign({}, options), { method: 'PATCH' }));\n/**\n * Perform an Http DELETE request given a set of options\n * @param options Options to build the HTTP request\n */\nexport const del = async (options) => request(Object.assign(Object.assign({}, options), { method: 'DELETE' }));\n","import { WebPlugin } from '@capacitor/core';\nimport * as Cookie from './cookie';\nimport * as Request from './request';\nexport class HttpWeb extends WebPlugin {\n    constructor() {\n        super();\n        /**\n         * Perform an Http request given a set of options\n         * @param options Options to build the HTTP request\n         */\n        this.request = async (options) => Request.request(options);\n        /**\n         * Perform an Http GET request given a set of options\n         * @param options Options to build the HTTP request\n         */\n        this.get = async (options) => Request.get(options);\n        /**\n         * Perform an Http POST request given a set of options\n         * @param options Options to build the HTTP request\n         */\n        this.post = async (options) => Request.post(options);\n        /**\n         * Perform an Http PUT request given a set of options\n         * @param options Options to build the HTTP request\n         */\n        this.put = async (options) => Request.put(options);\n        /**\n         * Perform an Http PATCH request given a set of options\n         * @param options Options to build the HTTP request\n         */\n        this.patch = async (options) => Request.patch(options);\n        /**\n         * Perform an Http DELETE request given a set of options\n         * @param options Options to build the HTTP request\n         */\n        this.del = async (options) => Request.del(options);\n        /**\n         * Gets all HttpCookies as a Map\n         */\n        this.getCookiesMap = async (\n        // @ts-ignore\n        options) => {\n            const cookies = Cookie.getCookies();\n            const output = {};\n            for (const cookie of cookies) {\n                output[cookie.key] = cookie.value;\n            }\n            return output;\n        };\n        /**\n         * Get all HttpCookies as an object with the values as an HttpCookie[]\n         */\n        this.getCookies = async (options) => {\n            // @ts-ignore\n            const { url } = options;\n            const cookies = Cookie.getCookies();\n            return { cookies };\n        };\n        /**\n         * Set a cookie\n         * @param key The key to set\n         * @param value The value to set\n         * @param options Optional additional parameters\n         */\n        this.setCookie = async (options) => {\n            const { key, value, expires = '', path = '' } = options;\n            Cookie.setCookie(key, value, { expires, path });\n        };\n        /**\n         * Gets all cookie values unless a key is specified, then return only that value\n         * @param key The key of the cookie value to get\n         */\n        this.getCookie = async (options) => Cookie.getCookie(options.key);\n        /**\n         * Deletes a cookie given a key\n         * @param key The key of the cookie to delete\n         */\n        this.deleteCookie = async (options) => Cookie.deleteCookie(options.key);\n        /**\n         * Clears out cookies by setting them to expire immediately\n         */\n        this.clearCookies = async (\n        // @ts-ignore\n        options) => Cookie.clearCookies();\n        /**\n         * Clears out cookies by setting them to expire immediately\n         */\n        this.clearAllCookies = async () => Cookie.clearCookies();\n        /**\n         * Uploads a file through a POST request\n         * @param options TODO\n         */\n        this.uploadFile = async (options) => {\n            const formData = new FormData();\n            formData.append(options.name, options.blob || 'undefined');\n            const fetchOptions = Object.assign(Object.assign({}, options), { body: formData, method: 'POST' });\n            return this.post(fetchOptions);\n        };\n        /**\n         * Downloads a file\n         * @param options TODO\n         */\n        this.downloadFile = async (options) => {\n            const requestInit = Request.buildRequestInit(options, options.webFetchExtra);\n            const response = await fetch(options.url, requestInit);\n            let blob;\n            if (!(options === null || options === void 0 ? void 0 : options.progress))\n                blob = await response.blob();\n            else if (!(response === null || response === void 0 ? void 0 : response.body))\n                blob = new Blob();\n            else {\n                const reader = response.body.getReader();\n                let bytes = 0;\n                let chunks = [];\n                const contentType = response.headers.get('content-type');\n                const contentLength = parseInt(response.headers.get('content-length') || '0', 10);\n                while (true) {\n                    const { done, value } = await reader.read();\n                    if (done)\n                        break;\n                    chunks.push(value);\n                    bytes += (value === null || value === void 0 ? void 0 : value.length) || 0;\n                    const status = {\n                        type: 'DOWNLOAD',\n                        url: options.url,\n                        bytes,\n                        contentLength,\n                    };\n                    this.notifyListeners('progress', status);\n                }\n                let allChunks = new Uint8Array(bytes);\n                let position = 0;\n                for (const chunk of chunks) {\n                    if (typeof chunk === 'undefined')\n                        continue;\n                    allChunks.set(chunk, position);\n                    position += chunk.length;\n                }\n                blob = new Blob([allChunks.buffer], { type: contentType || undefined });\n            }\n            return {\n                blob,\n            };\n        };\n    }\n}\n"]}