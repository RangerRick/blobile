{"version":3,"sources":["webpack:///node_modules/@capacitor-community/http/dist/esm/utils.js","webpack:///node_modules/@capacitor-community/http/dist/esm/cookie.js","webpack:///node_modules/@capacitor-community/http/dist/esm/request.js","webpack:///node_modules/@capacitor-community/http/dist/esm/web.js"],"names":["encode","str","encodeURIComponent","replace","decodeURIComponent","escape","decode","getCookies","output","map","document","cookie","split","k","v","trim","Object","entries","key","value","push","buildRequestInit","options","extra","assign","method","headers","type","originalKeys","keys","toLocaleLowerCase","reduce","acc","index","includes","params","URLSearchParams","data","set","body","toString","form","FormData","forEach","append","Headers","JSON","stringify","request","async","requestInit","webFetchExtra","urlParams","shouldEncode","accumulator","entry","encodedValue","item","Array","isArray","slice","substr","shouldEncodeUrlParams","url","fetch","response","contentType","get","ok","responseType","blob","Promise","resolve","reject","reader","FileReader","onload","base64String","result","base64StringWithoutTags","indexOf","onerror","error","readAsDataURL","json","text","status","HttpWeb","constructor","super","this","Request","post","put","patch","del","getCookiesMap","cookies","Cookie","setCookie","expires","encodedKey","path","getCookie","deleteCookie","clearCookies","Date","toUTCString","uploadFile","formData","name","fetchOptions","downloadFile","WebPlugin"],"mappings":"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","file":"x","sourcesContent":["/**\n * Read in a Blob value and return it as a base64 string\n * @param blob The blob value to convert to a base64 string\n */\nexport const readBlobAsBase64 = async (blob) => new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n        const base64String = reader.result;\n        const base64StringWithoutTags = base64String.substr(base64String.indexOf(',') + 1); // remove prefix \"data:application/pdf;base64,\"\n        resolve(base64StringWithoutTags);\n    };\n    reader.onerror = (error) => reject(error);\n    reader.readAsDataURL(blob);\n});\n/**\n * Safely web encode a string value (inspired by js-cookie)\n * @param str The string value to encode\n */\nexport const encode = (str) => encodeURIComponent(str)\n    .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)\n    .replace(/[()]/g, escape);\n/**\n * Safely web decode a string value (inspired by js-cookie)\n * @param str The string value to decode\n */\nexport const decode = (str) => str.replace(/(%[\\dA-F]{2})+/gi, decodeURIComponent);\n//# sourceMappingURL=utils.js.map","import { encode, decode } from './utils';\n/**\n * Set a cookie\n * @param key The key to set\n * @param value The value to set\n * @param options Optional additional parameters\n */\nexport const setCookie = (key, value, options = {}) => {\n    // Safely Encoded Key/Value\n    const encodedKey = encode(key);\n    const encodedValue = encode(value);\n    // Clean & sanitize options\n    const expires = `; expires=${(options.expires || '').replace('expires=', '')}`; // Default is \"; expires=\"\n    const path = (options.path || '/').replace('path=', ''); // Default is \"path=/\"\n    document.cookie = `${encodedKey}=${encodedValue || ''}${expires}; path=${path}`;\n};\n/**\n * Gets all HttpCookies\n */\nexport const getCookies = () => {\n    const output = [];\n    const map = {};\n    if (!document.cookie) {\n        return output;\n    }\n    const cookies = document.cookie.split(';') || [];\n    for (const cookie of cookies) {\n        // Replace first \"=\" with CAP_COOKIE to prevent splitting on additional \"=\"\n        let [k, v] = cookie.replace(/=/, 'CAP_COOKIE').split('CAP_COOKIE');\n        k = decode(k).trim();\n        v = decode(v).trim();\n        map[k] = v;\n    }\n    const entries = Object.entries(map);\n    for (const [key, value] of entries) {\n        output.push({\n            key,\n            value,\n        });\n    }\n    return output;\n};\n/**\n * Gets a single HttpCookie given a key\n */\nexport const getCookie = (key) => {\n    const cookies = getCookies();\n    for (const cookie of cookies) {\n        if (cookie.key === key) {\n            return cookie;\n        }\n    }\n    return {\n        key,\n        value: '',\n    };\n};\n/**\n * Deletes a cookie given a key\n * @param key The key of the cookie to delete\n */\nexport const deleteCookie = (key) => {\n    document.cookie = `${key}=; Max-Age=0`;\n};\n/**\n * Clears out cookies by setting them to expire immediately\n */\nexport const clearCookies = () => {\n    const cookies = document.cookie.split(';') || [];\n    for (const cookie of cookies) {\n        document.cookie = cookie\n            .replace(/^ +/, '')\n            .replace(/=.*/, `=;expires=${new Date().toUTCString()};path=/`);\n    }\n};\n//# sourceMappingURL=cookie.js.map","import { readBlobAsBase64 } from './utils';\n/**\n * Normalize an HttpHeaders map by lowercasing all of the values\n * @param headers The HttpHeaders object to normalize\n */\nconst normalizeHttpHeaders = (headers = {}) => {\n    const originalKeys = Object.keys(headers);\n    const loweredKeys = Object.keys(headers).map(k => k.toLocaleLowerCase());\n    const normalized = loweredKeys.reduce((acc, key, index) => {\n        acc[key] = headers[originalKeys[index]];\n        return acc;\n    }, {});\n    return normalized;\n};\n/**\n * Builds a string of url parameters that\n * @param params A map of url parameters\n * @param shouldEncode true if you should encodeURIComponent() the values (true by default)\n */\nconst buildUrlParams = (params, shouldEncode = true) => {\n    if (!params)\n        return null;\n    const output = Object.entries(params).reduce((accumulator, entry) => {\n        const [key, value] = entry;\n        let encodedValue;\n        let item;\n        if (Array.isArray(value)) {\n            item = '';\n            value.forEach(str => {\n                encodedValue = shouldEncode ? encodeURIComponent(str) : str;\n                item += `${key}=${encodedValue}&`;\n            });\n            // last character will always be \"&\" so slice it off\n            item.slice(0, -1);\n        }\n        else {\n            encodedValue = shouldEncode ? encodeURIComponent(value) : value;\n            item = `${key}=${encodedValue}`;\n        }\n        return `${accumulator}&${item}`;\n    }, '');\n    // Remove initial \"&\" from the reduce\n    return output.substr(1);\n};\n/**\n * Build the RequestInit object based on the options passed into the initial request\n * @param options The Http plugin options\n * @param extra Any extra RequestInit values\n */\nexport const buildRequestInit = (options, extra = {}) => {\n    const output = Object.assign({ method: options.method || 'GET', headers: options.headers }, extra);\n    // Get the content-type\n    const headers = normalizeHttpHeaders(options.headers);\n    const type = headers['content-type'] || '';\n    // Build request initializers based off of content-type\n    if (type.includes('application/x-www-form-urlencoded')) {\n        const params = new URLSearchParams();\n        for (const [key, value] of Object.entries(options.data || {})) {\n            params.set(key, value);\n        }\n        output.body = params.toString();\n    }\n    else if (type.includes('multipart/form-data')) {\n        const form = new FormData();\n        if (options.data instanceof FormData) {\n            options.data.forEach((value, key) => {\n                form.append(key, value);\n            });\n        }\n        else {\n            for (let key of Object.keys(options.data)) {\n                form.append(key, options.data[key]);\n            }\n        }\n        output.body = form;\n        const headers = new Headers(output.headers);\n        headers.delete('content-type'); // content-type will be set by `window.fetch` to includy boundary\n        output.headers = headers;\n    }\n    else if (type.includes('application/json') ||\n        typeof options.data === 'object') {\n        output.body = JSON.stringify(options.data);\n    }\n    return output;\n};\n/**\n * Perform an Http request given a set of options\n * @param options Options to build the HTTP request\n */\nexport const request = async (options) => {\n    const requestInit = buildRequestInit(options, options.webFetchExtra);\n    const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);\n    const url = urlParams ? `${options.url}?${urlParams}` : options.url;\n    const response = await fetch(url, requestInit);\n    const contentType = response.headers.get('content-type') || '';\n    // Default to 'text' responseType so no parsing happens\n    let { responseType = 'text' } = response.ok ? options : {};\n    // If the response content-type is json, force the response to be json\n    if (contentType.includes('application/json')) {\n        responseType = 'json';\n    }\n    let data;\n    switch (responseType) {\n        case 'arraybuffer':\n        case 'blob':\n            const blob = await response.blob();\n            data = await readBlobAsBase64(blob);\n            break;\n        case 'json':\n            data = await response.json();\n            break;\n        case 'document':\n        case 'text':\n        default:\n            data = await response.text();\n    }\n    // Convert fetch headers to Capacitor HttpHeaders\n    const headers = {};\n    response.headers.forEach((value, key) => {\n        headers[key] = value;\n    });\n    return {\n        data,\n        headers,\n        status: response.status,\n        url: response.url,\n    };\n};\n/**\n * Perform an Http GET request given a set of options\n * @param options Options to build the HTTP request\n */\nexport const get = async (options) => request(Object.assign(Object.assign({}, options), { method: 'GET' }));\n/**\n * Perform an Http POST request given a set of options\n * @param options Options to build the HTTP request\n */\nexport const post = async (options) => request(Object.assign(Object.assign({}, options), { method: 'POST' }));\n/**\n * Perform an Http PUT request given a set of options\n * @param options Options to build the HTTP request\n */\nexport const put = async (options) => request(Object.assign(Object.assign({}, options), { method: 'PUT' }));\n/**\n * Perform an Http PATCH request given a set of options\n * @param options Options to build the HTTP request\n */\nexport const patch = async (options) => request(Object.assign(Object.assign({}, options), { method: 'PATCH' }));\n/**\n * Perform an Http DELETE request given a set of options\n * @param options Options to build the HTTP request\n */\nexport const del = async (options) => request(Object.assign(Object.assign({}, options), { method: 'DELETE' }));\n//# sourceMappingURL=request.js.map","import { WebPlugin } from '@capacitor/core';\nimport * as Cookie from './cookie';\nimport * as Request from './request';\nexport class HttpWeb extends WebPlugin {\n    constructor() {\n        super();\n        /**\n         * Perform an Http request given a set of options\n         * @param options Options to build the HTTP request\n         */\n        this.request = async (options) => Request.request(options);\n        /**\n         * Perform an Http GET request given a set of options\n         * @param options Options to build the HTTP request\n         */\n        this.get = async (options) => Request.get(options);\n        /**\n         * Perform an Http POST request given a set of options\n         * @param options Options to build the HTTP request\n         */\n        this.post = async (options) => Request.post(options);\n        /**\n         * Perform an Http PUT request given a set of options\n         * @param options Options to build the HTTP request\n         */\n        this.put = async (options) => Request.put(options);\n        /**\n         * Perform an Http PATCH request given a set of options\n         * @param options Options to build the HTTP request\n         */\n        this.patch = async (options) => Request.patch(options);\n        /**\n         * Perform an Http DELETE request given a set of options\n         * @param options Options to build the HTTP request\n         */\n        this.del = async (options) => Request.del(options);\n        /**\n         * Gets all HttpCookies as a Map\n         */\n        this.getCookiesMap = async () => {\n            const cookies = Cookie.getCookies();\n            const output = {};\n            for (const cookie of cookies) {\n                output[cookie.key] = cookie.value;\n            }\n            return output;\n        };\n        /**\n         * Get all HttpCookies as an object with the values as an HttpCookie[]\n         */\n        this.getCookies = async (options) => {\n            // @ts-ignore\n            const { url } = options;\n            const cookies = Cookie.getCookies();\n            return { cookies };\n        };\n        /**\n         * Set a cookie\n         * @param key The key to set\n         * @param value The value to set\n         * @param options Optional additional parameters\n         */\n        this.setCookie = async (options) => {\n            const { key, value, expires = '', path = '' } = options;\n            Cookie.setCookie(key, value, { expires, path });\n        };\n        /**\n         * Gets all cookie values unless a key is specified, then return only that value\n         * @param key The key of the cookie value to get\n         */\n        this.getCookie = async (options) => Cookie.getCookie(options.key);\n        /**\n         * Deletes a cookie given a key\n         * @param key The key of the cookie to delete\n         */\n        this.deleteCookie = async (options) => Cookie.deleteCookie(options.key);\n        /**\n         * Clears out cookies by setting them to expire immediately\n         */\n        this.clearCookies = async (\n        // @ts-ignore\n        options) => Cookie.clearCookies();\n        /**\n         * Uploads a file through a POST request\n         * @param options TODO\n         */\n        this.uploadFile = async (options) => {\n            const formData = new FormData();\n            formData.append(options.name, options.blob || 'undefined');\n            const fetchOptions = Object.assign(Object.assign({}, options), { body: formData, method: 'POST' });\n            return this.post(fetchOptions);\n        };\n        /**\n         * Downloads a file\n         * @param options TODO\n         */\n        this.downloadFile = async (options) => {\n            const requestInit = Request.buildRequestInit(options, options.webFetchExtra);\n            const response = await fetch(options.url, requestInit);\n            const blob = await response.blob();\n            return {\n                blob,\n            };\n        };\n    }\n}\n//# sourceMappingURL=web.js.map"]}